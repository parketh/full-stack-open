# Part 2 - (a) Rendering a collection, modules

## Recap of past topics

 - Use `console.log` as much as possible to debug code
 - Concatenate statements using comma seperation rather than the Python way (e.g. `console.log('props value is', props)`)
 - Use Visual Studio Code snippets and tab completion to code faster (e.g. type `log` followed by `tab` key to create `console.log()` command)

## JavaScript Arrays

Recap of functional programming with arrays in JavaScript.

### 1 - Higher-order functions

 - In functional programming, functions are values. Variables can be assigned functions as a value and passed around. 
 - Higher-order functions refer to the passing of functions to other functions. Higher-order functions enable **composition**.
 - One example of a higher-order function is `filter`, which is a function on an array which accepts another function as an argument, which it uses to return a new, filtered version of the array. The function that is accepted is an argument is known as a **callback function**. 
 - In the example below, the use of `filter` allows us to write less code to capture the same logic, becaus the functions compose together.

```javascript
var animals = [
    { name: 'Fluffykins', species: 'rabbit' },
    { name: 'Caro', species: 'dog' },
    { name: 'Hamilton', species: 'dog' },
    { name: 'Harold', species: 'fish' },
    { name: 'Ursula', species: 'cat' },
    { name: 'Jimmy', species: 'fish' }
]

var dogs = animals.filter(function(animal) {
    return animal.species === 'dog'
})

/* Alternative method of implementing a filter
var dogs = []
for (var i = 0; i < animals.length; i++) {
    if (animals[i].species == 'dog')
        dogs.push(animals[i])
}*/
```
 - The callback function can also be declared seperately so that it is easier to think through conceptually and debug.

```javascript
var isDog = function(animal) {
    return animal.species === 'dog'
}

var dogs = animals.filter(isDog)
```

### 2 - Map

 - Like `filter`, the function `map` is a higher-order function. Rather than filtering through objects in an array, it transforms them. 
 - `map` takes a callback function and passes it to each item in the array

```javascript
var animals = [
    { name: 'Fluffykins', species: 'rabbit' },
    { name: 'Caro', species: 'dog' },
    { name: 'Hamilton', species: 'dog' },
    { name: 'Harold', species: 'fish' },
    { name: 'Ursula', species: 'cat' },
    { name: 'Jimmy', species: 'fish' }
]

var names = animals.map(function(animal) {
    return animal.name
})

/*
var names = []
for (var i = 0; i < animals.length; i++) {
    names.push(animals[i].name)
        
}*/
```

 - The code can be further reduced by using arrow notation, which removes the need to write `function()` and `return`.

```javascript
var names = animals.map((animal) => animal.name)
```


### 3 - Reduce basics

 - Previous functions, `map` and `filter`, and others like `find` (same as `filter` but only returns first item) are all list transformations
 - `reduce` is the multi-tool of list transformations in that it can be used to implement functions like `map`, `filter`, `find`, or any other list transformation
 - `reduce` can be used when no pre-built tools exist for required purposes
 - In the example below, the function is run once per item of the array. After the first iteration, the amount 250 is passed in as `sum` in the second iteration, added to 400, and the total 540 is passed in as `sum in the third iteration, and so on.

```javascript
var orders = [
    { amount: 250 },
    { amount: 400 },
    { amount: 100 },
    { amount: 325 }
]

var totalAmount = orders.reduce(function(sum, order) {
    return sum + order.amount
}

/*
var totalAmount = 0
for (var i = 0; i < orders.length; i++) {
    totalAmount += orders[i].amount
}*/
```
 - As before, the `reduce` function can be further reduced in length using arrow notation. 

```javascript
var totalAmount = orders.reduce((sum, order) => sum + order.amount)
```

## Rendering Collections, Key-Attribute and Map

Data can be declared in `index.js` and passed to `App.js`, in the same way as a prop. Here, a list of three notes are passed from `index.js` to `App.js` and rendered using the `map` function. Note that:
 - the JavaScript expression of which `map` forms a part is wrapped in curly braces.
 - the items in the list generated by the `map` method must have a unique `key` value, which React uses to update the view when the component is re-rendered.

**index.js**
```javascript
import ReactDOM from 'react-dom'
import App from './App.js'

const notes = [
  {
    id: 1,
    content: 'HTML is easy',
    date: '2019-05-30T17:30:31.098Z',
    important: true
  },
  {
    id: 2,
    content: 'Browser can execute only JavaScript',
    date: '2019-05-30T18:39:34.091Z',
    important: false
  },
  {
    id: 3,
    content: 'GET and POST are the most important methods of HTTP protocol',
    date: '2019-05-30T19:20:14.298Z',
    important: true
  }
]

ReactDOM.render(
  <App notes={notes} />,
  document.getElementById('root')
)
```

**App.js**
```javascript
import React from 'react'

const App = ({ notes }) => {
  return (
    <div>
      <h1>Notes</h1>
      <ul>
        { notes.map(note => <li key={note.id}>{note.content}</li>) }
      </ul>
    </div>
  )
}

export default App
```

##  Anti-Pattern: Array Indexes as Keys

When passing an array into the `map` function, we can retrieve the array indexes by passing a second parameter into the callback function, as shown below:

```javascript
notes.map((note, i) => ...)
```

`Ã¬` is assigned the index of the position in the array in which each note resides. However, this is **not recommend** as it can create undesirable problems.

## Refactoring modules

Converting each note into its own seperate component in the above code changes the syntax for using the `map` function. Instead of defining an `id` key value within the `<li>` tag, it is now defined as an attribute for the Note components.

**App.js**

```javascript
const Note = ({ note }) => {
  return (
    <li>{note.content}</li>
  )
}

const App = ({ notes }) => {
  return (
    <div>
      <h1>Notes</h1>
      <ul>
        {notes.map(note => 
          <Note key={note.id} note={note} />
        )}
      </ul>
    </div>
  )
}
```

React applications are written such that each component is declared in its own JavaScript file as an *ES6-module*. These are imported at the start of `index.js`.

```javascript
import ReactDOM from 'react-dom'
import App from './App.js'
```

In smaller applications, components are usually placed in a directory called `components`, which is in turn placed within the `src` directory. The convention is to name the file after the component. 

The final line `export default Note` exports the declared component so that it to be imported in `App.js`. When importing the file, its location must be specified relative to the location of the importing file (although the file extension `.js` can be omitted).

**components/note.js**

```javascript
import React from 'react'

const Note = ({ note }) => {
  return (
    <li>{note.content}</li>
  )
}

export default Note
```

**App.js**

```javascript
import React from 'react'
import Note from './components/Note'

const App = ({ notes }) => {
  // ...
}
```

## Debugging

 - Use `console.log` to hone in on the reason for the breakdown
 - Start with the first thing to be rendered (start of the `App` component) and move forward
 - Components declared as a single statement or a function without a return must be expressed in its longer form to allow us to add printing.

```javascript
// Short form
const Course = ({ course }) => (
  <div>
    <Header course={course} />
  </div>
)

// Long form
const Course = ({ course }) => { 
  console.log(course)
  return (
    <div>
      <Header course={course} />
    </div>
  )
}
```

 - We can also run `console.log(props)` to see what `props` actually contains. Errors often arise due to props being of the wrong type, or being called with a different name thant they actually are.
 - 